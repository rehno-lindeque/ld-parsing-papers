
\documentclass[11pt]{article}

%%%%%%%%%%%%%%%%%%% PACKAGES %%%%%%%%%%%%%%%%%%%
\usepackage{geometry}
\geometry{a4paper}
\usepackage{gcl}
%\usepackage{pfs}
%\usepackage{algorithmic}
%\usepackage{graphicx}
%\usepackage{epstopdf}
%\usepackage{natbib}
%\usepackage{fancyvrb}
\usepackage{float}
\usepackage{wrapfig}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{proof}

%%%%%%%%%%%%%%%%%%%% MACROS %%%%%%%%%%%%%%%%%%%%
% Grammars
%\newcommand {\GRAMMAR}
%  {\begin{indent} \begin{align*}}
%  %{\setlength{\parindent}{\GRAMMAR}\\
%  %\begin{indent}}

%\newcommand {\ENDGRAMMAR}
%  {\end{align*} \end{indent}}

\newenvironment{grammar}{\begin{align*}}{\end{align*}}
  
%  {\begin{indent} \begin{align*}}
%  {\end{align*} \end{indent}}
  
%\setlength{\topsep}{2mm}<
%\setlength{\parindent}{15pt}

%\newlength{\OBLS}\setlength{\OBLS}{\baselineskip}
%\newlength{\OPAR}\setlength{\OPAR}{\parindent}
%\newcommand{\pgskip}{\hspace{\mathindent}\=\+}
%\newcommand{\FOR}[1]{\FRM{\,#1\,}}
%\newcommand{\FRM}[1]{\mbox{$#1$}}
%\newcommand{\DERIVE}
%  {\setlength{\baselineskip}{1.3\baselineskip}
%  \begin{tabbing}
%  \hspace{\OPAR}\=\hspace{\OPAR}\=\hspace{\OPAR}\=\hspace{\OPAR}\=\hspace{\OPAR}\=\hspace{\OPAR}\=\kill
%  }
%\newcommand{\form}[1]
%  {\>\>\FOR{#1}}
%\newcommand{\hint}[2]
%  {\\*\>\FRM{#1}\>\>\{#2\}\\}
%\newcommand{\STARTPROOF}[1]
%  {\TOPROVE{#1}\\$\vartriangleright$ \>\>}
%\newcommand{\TOPROVE}[1]
%  {#1}
%\newcommand{\ENDDERIVE}
%  {\end{tabbing}\setlength{\baselineskip}{\OBLS}
%}
%\newcommand{\ENDPROOF}
%  {$\rbrack\arrowvert$\\
%  $\square$\\\\}
%\newcommand {\IND}
%  {\setlength{\parindent}{\OPAR}\\
%  \begin{indent}}
%\newcommand {\ENDIND}
%  {\end{indent}\\
%  \setlength{\parindent}{0 pt}\\}
%\newcommand {\IF}
%  {\mathbf{if} \:\:}
%\newcommand {\BAR}
%  {\ [\!] \:\:\:}
%\newcommand {\FI}
%  {\mathbf{fi} \:\:}
%\newcommand {\ARROW}
%  {\rightarrow}
%\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}}
%\newcommand{\TT} {\textit{true}}
%\newcommand{\FF} {\textit{false}}


%%%%%%%%%%%%%%%%%%%% MACROS %%%%%%%%%%%%%%%%%%%%
\floatstyle{plain}
\newfloat{grammar}{thp}{lop}
\floatname{grammar}{Grammar}


%%%%%%%%%%%%%%%%%%%%%Stuff from SICL article%%%%%%
%\newcommand{\sos}[1]{\mathcal{#1}}
%\newcommand{\sset}[1]{\texttt{#1}}
%\newcommand{\restr}[2]{#1\restriction#2}

%\def\universe{A}
%\def\Empty{\mbox{\O}}





%%%%%%%%%%%%%%%%%%% DOCUMENT %%%%%%%%%%%%%%%%%%%
\begin{document}

\title{A case for the use of delayed reductions in left-to-right parsing of context-free grammars}
\author{Rehno Lindeque
\\23123576}

\maketitle

\begin{abstract}
In this paper we suggest the use of delayed actions for generalized parsing of unambiguous context-free grammars. 
Our contention is that delayed reductions in a left-to-right parser might result in more efficient parsers than existing techniques 
and describes the nature of the parsing process in a more light-weight, intuitive manner.
This work is therefore intended as preparatory material for further research in this area.
To this end we develop a set of tools for studying and developing the semantics of delayed parsing actions.
A small pseudo instruction set is shown which includes delayed parsing actions used to resolve rules containing cycles in their lookahead sets.
Operational semantics for each of these instructions are described and the implementation of an interpreter for the instruction set is demonstrated.
In addition a prototype construction algorithm is presented capable of generating parsers for a limited subset of unambiguous grammars.
Finally we discuss the remaining problems with this technique and possible approaches to resolving them in future work.\\
\end{abstract}

\textbf{Keywords:} LD parsing, Recursive-ascent parsing, context-free grammars, generalized parsing, GLR parsing, LR parsing, LL parsing

\section{Introduction}

\subsection{Top-down vs Bottom-up parsing}
\emph{(TODO)\\ %BUSY HERE
LL parsing\\
LR parsing \cite{knuth65}\\
Recursive ascent parsers \cite{13326, 47909, 770849} }

\subsection{Generalized parsing approaches}

\emph{(TODO)\\ %BUSY HERE
Motivation: Translation versus recognition (why k $>$ 1 lookahead is needed) \cite{Parr95lland}\\
Generalized Parsing Techniques \cite{Thurston07}\\
Chart parsers: Earley $\rightarrow$ GLR \\
Right Nulled GLR Parsers \cite{1146810}\\
Performance of GLR Parser \cite{Mcpeak04elkhound:a}\\ %(Same asymptotic performance, but slower by about a factor of 10x according to \cite{Mcpeak04elkhound:a} due to complicated data structures (Stack Structured Graph)
%(todo: find a better reference?))\\
Previous work on delayed reductions (similar ideas, but rather different algorithms) \cite{1287949, Marc80, 991520, 146993}
}

\section{Delayed reductions}

\subsection{Basic strategy}
Our basic strategy for parsing grammars proceeds in two passes.
The first is a recognition pass where the sequence of reduction rules are recorded into a temporary buffer that grows in a stack-like manner and supports constant-time random-access.
In the second pass the sequence of recognized rules are applied consecutively in order to build the final parse tree in a manner similar to LR parser, but without any recognition steps or lookahead.
By separating these two steps into distinct passes, the recognition pass is allowed the convenience of identifying rules in a more flexible sequence.\\

The mechanism used to reorder rules in this paper is placeholder tokens representing delayed reductions.
Whenever a rule must be reduced that cannot be fully determined, a placeholder token is recorded in the buffer in its place. 
Once the reduction rule can be resolved the placeholder token is replaced with this rule number.
In order to keep track of placeholders we also record their indexes in a separate stack, allowing the parser to return to these tokens later on in order to replace them using random-access writes.\\

In effect placeholders are used in order delay reductions until some unspecified lookahead has been recognized.
Clearly the order of rule recognition is relaxed using this mechanism, however it is not completely unrestricted. 
The following conditions specify certain constraints by which the algorithm must abide.

\begin{itemize}
\item As rules are recognized they are placed in the buffer in a left-to-right order. This corresponds with a bottom-up parsing strategy since productions that are closer to the leaf nodes in the parse tree will normally be recognized before their parent rules are recognized.
\item Delayed rules may only be resolved in a right-to-left order, corresponding with the top-down strategy of parsing since delayed rules near the root of the tree must be resolved before 
rules near the leaf nodes can be resolved. 
It is worth noting however that, although the unresolved rules will only be resolved in a right-to-left order, rules may be added to the unresolved stack at any time which intuitively
causes the right-to-left rule resolution loop to be nested inside the main left-to-right recognition loop.
\end{itemize}

In order to explain this strategy in more formal terms we will define an instruction set and interpreter which in essence forms a tiny domain specific language for parsing with delayed actions.
For the sake of simplicity we begin by describing a simple modified LR(0) algorithm. This LR(0) algorithm has three basic operations: shift, reduce and switch. 
The shift and switch operations are responsible for recognizing terminal tokens on the input stream whereas the reduce action is responsible for translating strings of terminal tokens into nonterminal tokens.

An interpreter can be built to correctly execute these instructions. 
Using this approach we can demonstrate the operation of a parser constructed using this set of actions.
The following free variables will be used to represent the state of the parser interpreter during execution:

\begin{itemize}
\item $input_{[0, input.length)}$ is an array of input tokens of length $input.length$ returned by a lexer.
\item $i$ is an index into the array of input tokens representing the current position of the parser in the stream during the recognition pass such that $input_i$ is the token currently being tested.
This index will never be decreased and need only increase in increments of 1.
\item $actions_{[0, actions.length)}$ is a sequence of instructions representing the encoded parser similar to the source code that is output by known parser generators. 
This array is automatically generated by a separate parser construction algorithm which will be discussed later.
\item $j$ is an index into the array of actions such that $actions_j$ defines the current instruction being decoded.
\item $outputrules$ is dynamically growing array storing the output of recognition pass
\item $error$ is a special error state which (in the absence of error recovery) will halt the parser and report a syntax error.
\end{itemize}

Every action in the array will be represented in this format:\\
\texttt{ action ( [parameters\textellipsis] )}\\

Operational semantics for the following operations is discussed below, followed by the implementation of a basic LR(0) parser.
\begin{itemize}
\item \texttt{shift(terminaltoken)}
\item \texttt{switch([terminaltoken $\mapsto$ target, \textellipsis])}
\item \texttt{reduce(rule)}
\end{itemize}

\subsubsection{The `shift' action}
\texttt{shift(terminaltoken)}\\
The shift action is used to step over input tokens deterministicly. 
There are only two options: Either the token matches the parameter given to the shift action, or the parser is put into an error state.

\begin{equation}
\infer{i, j \mapsto i+1, j+1}{input_i = a & actions_j = shift(a)} \tag{Def 1.1}
\end{equation}

\begin{equation}
\infer{parserstate \mapsto error}{input_i = a & actions_j = shift(b)} \tag{Def 1.2}
\end{equation}\\

\subsubsection{The `switch' action}
\texttt{switch([terminaltoken $\Mapsto$ target, \textellipsis])}\\
The switch action is used to recognize input tokens nondeterministicly.
The set of parameters given to the switch action can be viewed as an associative map of key-value pairs where a terminal token maps to a parse state or an index into the generated parser code.
If a terminal token on the input stream is contained in the map then the switch action will cause the parser to jump to the new state similar to how switch- or case statements behave in many programming languages.
However, if the input terminal is not recognized by the switch action, then the parser is placed in the $error$ state.

\begin{equation}
\infer{i, j \mapsto i+1, gettarget(A, input_i)}{input_i \in A & actions_j = switch(A)} \tag{Def 1.3}
\end{equation}

\begin{equation}
\infer{error}{input_i \notin A & actions_j = switch(A)} \tag{Def 1.4}
\end{equation}\\

There is an apparent redundancy between the switch and the shift actions. 
We can see that a shift action of the form $shift(a)$ will behave similar to a switch action of the form $switch([a \Rightarrow i+1])$ where i+1 indicates the index of the next action to perform.
However the distinction is made between these two actions as a matter of convenience: 
Switch actions are viewed as the central recognition mechanism of the parser, because they involve a non-trivial choice.
By contrast, shift actions do not make any significant contribution to the internal state of the parser other than to catch syntax errors.

\subsubsection{The `reduce' action}
\texttt{reduce(rule)}\\
The parameter given to the reduce action is an index into a list of all rules in the given grammar where every rule is in the form \texttt{nonterminaltoken $\rightarrow$ terminaltoken \textellipsis}. 
A production in a grammar may be reduced from any number of different sequences of terminal tokens, however a rule recognizes only one possible sequence of terminal tokens.
In other words, given some rule both the left and right side of the reduction can be determined (although identifiers must still be stored).
For this reason we use rule numbers internally rather than using productions directly.

\begin{equation}
\infer{j, outputrules_k, k \mapsto j+1, r, k+1}{input_i \in A & actions_j = reduce(r)} \tag{Def 1.5}
\end{equation}\\

\subsubsection{Basic LR(0) parsing}

Since LR(0) grammars requires no look ahead they can be parsed directly using only recognition and reduction actions.
To see how these rules translate into a familiar language we construct an LR(0) parser for a simple grammar in the guarded command language (GCL) in a similar style to a recursive-ascent parser.

This simple grammar will be used for illustration, with $S$ representing the starting token.

\begin{align*}
G \equiv \quad & A_1 \rightarrow a\\
               & B_1 \rightarrow b\\
               & S_1 \rightarrow x A \$\\
               & S_2 \rightarrow x B \$\\
               & S_3 \rightarrow x y \$
\end{align*}

The parsing steps to recognize this grammar is:
1. The first token to be recognized must be $x$. Since the choice of $x$ is predetermined a shift action, $shift(x)$ may be used which also checks for an error in the input stream.

%\begin{figure}[htbp]
\begin{center}
\begin{gcl}
\IF input_i = x \rightarrow i \becomes i + 1;
\BAR input_i \neq x \rightarrow parserstate \becomes error;
\FI
\end{gcl}
\end{center}
%\end{figure}

2. Now, the set of valid tokens to follow are $\{ a, b, y \}$. 
Since this recognition involves a choice of $a$, $b$ or $y$ a logical branch occurs in the parser, indicating that a switch action must be employed.
The choice of branch will place the parser into one of three distinct states, hence it makes sense to indicate this by constructing a separate procedure for each.

%\begin{figure}[htbp]
\begin{center}
\begin{gcl}
\IF input_i = a \rightarrow 
                \qquad i \becomes i+1; 
                \qquad ParseS1(input, i);
\BAR input_i = b \rightarrow 
                \qquad i \becomes i+1;
                \qquad ParseS2(input, i);
\BAR input_i = y \rightarrow 
                \qquad i \becomes i+1; 
                \qquad ParseS3(input, i);
\BAR input_i \notin \{ a, b \} \rightarrow 
                \qquad parserstate \becomes error;
\FI
\end{gcl}
\end{center}
%\end{figure}

3. For each branch of the switch the remaining actions are fully deterministic. 
The first two branches must output their corresponding reduction rules $A_1$ and $B_1$. 
For example reduction rule $A_1$ may be performed as follows:

%\begin{figure}[htbp]
\begin{center}
\begin{gcl}
outputrules_k \becomes A_1;
k \becomes k + 1;
\end{gcl}
\end{center}
%\end{figure}

Now all that remains in each branch is to recognize the remaining `end-of-stream' token $\$$ and then output $S_1$, $S_2$ or $S_3$. 
The complete pseudo code that describes this process is listed below.

\begin{center}
\begin{gcl}
\PROC ParseS1(input)
outputrules_k \becomes A;
k \becomes k + 1;
\IF input_i = \$ \rightarrow 
                 \qquad i \becomes i + 1;
\BAR input_i \neq \$ \rightarrow 
                 \qquad parserstate \becomes error;
                 \qquad \textbf{return};
\FI
outputrules_k \becomes S_1;
k \becomes k + 1;
\CORP
\end{gcl}
\end{center}

\begin{center}
\begin{gcl}
\PROC ParseS2(input)
outputrules_k \becomes B;
k \becomes k + 1;
\IF input_i = \$ \rightarrow i \becomes i + 1;
\BAR input_i \neq \$ \rightarrow
                 \qquad parserstate \becomes error;
                 \qquad \textbf{return};
\FI
outputrules_k \becomes S_2;
k \becomes k + 1;
\CORP
\end{gcl}
\end{center}

\begin{center}
\begin{gcl}
\PROC ParseS3(input)
\IF input_i = \$ \rightarrow i \becomes i + 1;
\BAR input_i \neq \$ \rightarrow 
                 \qquad parserstate \becomes error;
                 \qquad \textbf{return};
\FI
outputrules_k \becomes S_3;
k \becomes k + 1;
\CORP
\end{gcl}
\end{center}

\begin{figure}[!h]
\begin{center}
\begin{gcl}
\PROC ParseG(input, output, parserstate)
i \becomes 0;
\IF input_i = x \rightarrow i \becomes i + 1;
\BAR input_i \neq x \rightarrow 
                \qquad parserstate \becomes error;
                \qquad \textbf{return};
\FI
\IF input_i = a \rightarrow
                \qquad i \becomes i+1;
                \qquad ParseS1(input, i);
\BAR input_i = b \rightarrow 
                \qquad i \becomes i+1;
                \qquad ParseS2(input, i);
\BAR input_i = y \rightarrow 
                \qquad i \becomes i+1;
                \qquad ParseS3(input, i);
\BAR input_i \notin \{ a, b \} \rightarrow 
                \qquad parserstate \becomes error; 
                \qquad \textbf{return};
\FI
\CORP
\end{gcl}
\caption{An LR(0) parser example explained in pseudo code.}
\end{center}
\end{figure}


\subsection{Delayed actions}
While the four operations discussed provide the necessary tools to recognize any LR(0) grammar, they do not provide any manner of looking ahead into the input stream.
Suppose that we add two more operations, \texttt{delay()} and \texttt{resolve(rule)} to our instruction set with the following semantics:\\

\subsubsection{The `delay' action}
\texttt{delay()}\\
The delay action adds a placeholder token called $ignore$ to the output rules which may be replaced later.
In addition the index of the placeholder is pushed onto the stack of delays.
Note that the value of $ignore$ should be reserved so that it will not conflict with any rule number.
\begin{equation}
\infer{delays_l, l, j, outputrules_k, k \mapsto j, l+1, j+1, ignore, k+1}{actions_j = delay()} \tag{Def 1.6}
\end{equation}\\

\subsubsection{The `resolve' action}
\texttt{resolve(rule)}\\
The resolve action is similar to the reduce action, but instead of immediately pushing a reduction rule onto the output stack it instead replaces the placeholder token previously pushed by a delay action.
It may also push the special token $ignore$, meaning that the output rules should stay unchanged and no reduction is necessary. 
Since the index of this placeholder has been popped from the stack, this delay will not be re-evaluated again.
\begin{equation}
\infer{l, j, outputrules_{delays_l} \mapsto l-1, j+1, ignore}{actions_j = resolve(r)} \tag{Def 1.7}
\end{equation}\\

This pair of actions, `resolve' and `delay', works together in order to implement \emph{delayed reductions}. 
It is easy to see that the action $delay()$ immediately followed by the action $resolve(r)$ is identical to our original action $reduce(r)$ and could be used as a replacement.
\footnote{However we've chosen to leave the original reduce action because the greater majority of actions in programming language grammars are deterministic.}.
In the remainder of this section we will show how lookahead can be implemented by placing other actions between these two actions.

\subsubsection{A modification of the `switch' and `return' actions}
In order for the before mentioned pair of action to work together correctly we must also modify our original switch and return actions.
\begin{equation}
\infer{j, m \mapsto continuations_m, m-1}{actions_j = return()} \tag{Def 1.8}
\end{equation}\\

\begin{equation}
\infer{i, j \mapsto i+1, gettarget(A, input_i)}{input_i \in A & actions_j = switch(A)} \tag{Def 1.9}
\end{equation}\\


\subsection{Traces}
To see how the delay/resolve pair can be used to look ahead in the we must investigate several different forms of grammar rules.
In order to do this we must generate all possible input strings for each form. 
The concept of traces is used to show the actions that the parser must take for possibility.
A trace is simply a sequence of actions that the parser must take to recognize a particular instance of a valid input stream for the given grammar.
A mechanical method of generating traces is used such that every possibility could be enumerated, although on should be aware that the trace itself may not be finite.\\

In the following examples capitalized tokens represent nonterminals with subscripts differentiating between nonterminals produced by different rules. 
Lowercase tokens represent terminals and $S$ is always the starting nonterminal. 
Finally, $\$$ represents the special `end-of-stream' terminal indicating that no more input tokens remain.\\

%%%%%%%%%%%%% Example 1: Simple grammar
\subsubsection{Reduction based on a fixed lookahead}
\begin{tabular}[t]{cl}
\parbox{.3\textwidth}{
\begin{align*}
G_1 \equiv \quad & A_1 \rightarrow x\\
                 & B_1 \rightarrow x\\
                 & S_1 \rightarrow A a \$\\
                 & S_2 \rightarrow B b \$
\end{align*}}
\parbox{.8\textwidth}{A simple grammar two possible reductions.}
\end{tabular}

\parbox{.3\textwidth}{\begin{align*}
&traces(G_1) \equiv \\
\{ & \langle shift(x), reduce(A_1), switch(a), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), reduce(B_1), switch(b), shift(\$), reduce(S_2) \rangle \}
\end{align*}}

However, note that this trace also be expanded with delay actions, so that the lookahead could be implemented. Hence an equivalent trace to the above is:

\parbox{.3\textwidth}{\begin{align*}
&traces(G_1) \equiv \\
\{ & \langle shift(x), switch(a), reduce(A_1), shift(\$), reduce(S_1) \rangle, \\
   & \langle shift(x), switch(b), reduce(B_1), shift(\$), reduce(S_2) \rangle \}
\end{align*}}

%%%%%%%%%%%%% Example 2: Optional reduction based on a fixed lookahead
\subsubsection{Optional reduction based on a fixed lookahead}
\begin{tabular}[t]{cl}
\parbox{.3\textwidth}{
\begin{align*}
G_2 \equiv \quad & A_1 \rightarrow x\\
                 & S_1 \rightarrow A a \$\\
                 & S_2 \rightarrow x b \$
\end{align*}}
\parbox{.8\textwidth}{Here is a simple grammar requiring lookahead, but where some reductions do not take place.}
\end{tabular}

\parbox{.3\textwidth}{\begin{align*}
&traces(G_2) \equiv \\
\{ & \langle shift(x), reduce(A_1), switch(a), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), switch(b), shift(\$), reduce(S_2) \rangle \}
\end{align*}}

The equivalent trace with delays can be written as follows:

\parbox{.3\textwidth}{\begin{align*}
&traces(G_2) \equiv \\
\{ & \langle shift(x), switch(a), reduce(A_1), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), switch(b), shift(\$), reduce(S_2) \rangle \}
\end{align*}}

%%%%%%%%%%%%% Example 3: Disjointed reductions that require lookahead
\subsubsection{Disjointed reductions that require lookahead}
\begin{tabular}[t]{cl}
\parbox{.3\textwidth}{
\begin{align*}
G_3 \equiv \quad & A_1 \rightarrow x y\\
                 & B_1 \rightarrow y b\\
                 & C_1 \rightarrow x\\
                 & S_1 \rightarrow A a \$\\
                 & S_2 \rightarrow C B \$
\end{align*}}
\parbox{.8\textwidth}{sfd}
\end{tabular}

\parbox{.3\textwidth}{\begin{align*}
&traces(G_3) \equiv \\
\{ & \langle shift(x), shift(y), reduce(A_1), switch(a), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), reduce(C_1), shift(y), switch(b), reduce(B_1), shift(\$), reduce(S_2) \rangle \}
\end{align*}}

The equivalent trace with delays can be written as follows:

\parbox{.3\textwidth}{\begin{align*}
&traces(G_3) \equiv \\
\{ & \langle shift(x), shift(y), switch(a), reduce(A_1), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), shift(y), switch(b), reduce(C_1), reduce(B_1), shift(\$), reduce(S_2) \rangle \}
\end{align*}}

%%%%%%%%%%%%% Example 4: Right recursive grammars
\subsubsection{Right recursive grammars}
\begin{tabular}[t]{cl}
\parbox{.3\textwidth}{
\begin{align*}
G_4 \equiv \quad & A_1 \rightarrow x\\
                 & A_2 \rightarrow x A\\
                 & B_1 \rightarrow x\\
                 & B_2 \rightarrow x B\\
                 & S_1 \rightarrow A a \$\\
                 & S_2 \rightarrow B b \$
\end{align*}}
\parbox{.8\textwidth}{sfd}
\end{tabular}

\parbox{.3\textwidth}{\begin{align*}
&traces(G_4) \equiv \\
\{ & \langle shift(x), reduce(A_1), switch(a), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), shift(x), reduce(A_1), reduce(A_2), switch(a), shift(\$), reduce(S_1) \rangle, \textellipsis \\
   & \langle shift(x), reduce(B_1), switch(b), reduce(S_2) \rangle,\\
   & \langle shift(x), shift(x), reduce(B_1), reduce(B_2), switch(b), shift(\$), reduce(S_2) \rangle, \textellipsis \}
\end{align*}}

The equivalent trace with delays can be written as follows:

\parbox{.3\textwidth}{\begin{align*}
&traces(G_4) \equiv \\
\{ & \langle shift(x), delay, switch(a), resolve(A_1), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), shift(x), delay, delay, switch(a), resolve(A_2), resolve(A_1), shift(\$), reduce(S_1) \rangle, \textellipsis \\
   & \langle shift(x), delay, switch(b), resolve(B_1), shift(\$), reduce(S_2) \rangle,\\
   & \langle shift(x), shift(x), delay, delay, switch(b), resolve(B_2), resolve(B_1), shift(\$), reduce(S_2) \rangle, \textellipsis \}
\end{align*}}

%%%%%%%%%%%%% Example 5: Combined left and right recursive grammar
\subsubsection{Combined left and right recursive grammar}
\begin{tabular}[t]{cl}
\parbox{.3\textwidth}{
\begin{align*}
G_5 \equiv \quad & A_1 \rightarrow x\\
                 & A_2 \rightarrow x A\\
                 & B_1 \rightarrow x\\
                 & B_2 \rightarrow B x\\
                 & S_1 \rightarrow A a \$\\
                 & S_2 \rightarrow B b \$
\end{align*}}
\parbox{.8\textwidth}{sfd}
\end{tabular}

\parbox{.3\textwidth}{\begin{align*}
&traces(G_5) \equiv \\
\{ & \langle shift(x), delay, switch(a), resolve(A_1), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), shift(x), delay, delay, switch(a), resolve(A_2), resolve(A_1), shift(\$), reduce(S_1) \rangle, \textellipsis \\
   & \langle shift(x), delay, switch(b), resolve(B_1), shift(\$), reduce(S_2) \rangle,\\
   & \langle shift(x), shift(x), delay, delay, switch(b), resolve(B_2), resolve(B_1), shift(\$), reduce(S_2) \rangle, \textellipsis \}
\end{align*}}

The equivalent trace with delays can be written as follows:

\parbox{.3\textwidth}{\begin{align*}
&traces(G_5) \equiv \\
\{ & \langle shift(x), delay, switch(a), resolve(A_1), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), shift(x), delay, delay, switch(a), resolve(A_2), resolve(A_1), shift(\$), reduce(S_1) \rangle, \textellipsis \\
   & \langle shift(x), delay, switch(b), resolve(B_1), shift(\$), reduce(S_2) \rangle,\\
   & \langle shift(x), shift(x), delay, delay, switch(b), resolve(B_2), resolve(B_1), shift(\$), reduce(S_2) \rangle, \textellipsis \}
\end{align*}}

%%%%%%%%%%%%% Example 6: 
\subsubsection{}
\begin{tabular}[t]{cl}
\parbox{.3\textwidth}{
\begin{align*}
G_6 \equiv \quad & A_1 \rightarrow x\\
                 & B_1 \rightarrow x\\
                 & C_1 \rightarrow y\\
                 & C_2 \rightarrow A C a\\
                 & C_3 \rightarrow B C b\\
                 & S_1 \rightarrow C \$
\end{align*}}
\parbox{.8\textwidth}{sfd}
\end{tabular}s

\parbox{.3\textwidth}{\begin{align*}
&traces(G_6) \equiv \\
\{ & \langle switch(y), reduce(C_1), shift(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(A_1), switch(y), reduce(C_1), switch(a), reduce(C_2), shift(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(B_1), switch(y), reduce(C_1), switch(b), reduce(C_3), shift(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(A_1), switch(x), reduce(A_1), switch(y), reduce(C_1), switch(a), reduce(C_2), \\&\qquad switch(a), reduce(C_2), shift(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(A_1), switch(x), reduce(B_1), switch(y), reduce(C_1), switch(b), reduce(C_3), \\&\qquad switch(a), reduce(C_2), shift(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(B_1), switch(x), reduce(A_1), switch(y), reduce(C_1), switch(a), reduce(C_2), \\&\qquad switch(b), reduce(C_3), shift(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(B_1), switch(x), reduce(B_1), switch(y), reduce(C_1), switch(b), reduce(C_3), \\&\qquad switch(b), reduce(C_3), shift(\$), reduce(S_1) \rangle,\\
   & \textellipsis \}
\end{align*}}

The equivalent trace with delays can be written as follows:

\parbox{.3\textwidth}{\begin{align*}
%\begin{equation*}
&traces(G_6) \equiv \\
\{ & \langle switch(y), reduce(C_1), shift(\$), reduce(S_1) \rangle,\\ 
%\begin{array}{l}
   &  \langle switch(x), delay(A,B), switch(y), reduce(C_1), switch(a), resolve(A), reduce(C_2), shift(\$), \\&\qquad reduce(S_1) \rangle,\\
   &  \langle switch(x), delay(A,B), switch(y), reduce(C_1), switch(b), resolve(B), reduce(C_3), shift(\$), \\&\qquad reduce(S_1) \rangle,\\
   &  \langle switch(x), delay(A,B), switch(x), delay(A,B), switch(y), reduce(C_1), switch(a), resolve(A), \\&\qquad reduce(C_2), switch(a), resolve(A), reduce(C_2), shift(\$), reduce(S_1) \rangle,\\
   &  \langle switch(x), delay(A,B), switch(x), delay(A,B), switch(y), reduce(C_1), switch(b), resolve(B), \\&\qquad reduce(C_3), switch(a), resolve(A), reduce(C_2), shift(\$), reduce(S_1) \rangle,\\
   &  \langle switch(x), delay(A,B), switch(x), delay(A,B), switch(y), reduce(C_1), switch(a), resolve(A), \\&\qquad reduce(C_2), switch(b), resolve(B), reduce(C_3), shift(\$), reduce(S_1) \rangle,\\
   &  \langle switch(x), delay(A,B), switch(x), delay(A,B), switch(y), reduce(C_1), switch(b), resolve(B), \\&\qquad reduce(C_3), switch(b), resolve(B), reduce(C_3), shift(\$), reduce(S_1) \rangle,\\
   &  \textellipsis
%\end{array}
\}
%\end{equation*}
\end{align*}}

%%%%%%%%%%%%% Example 7: 
\subsubsection{}
\begin{tabular}[t]{cl}
\parbox{.3\textwidth}{
\begin{align*}
G_7 \equiv \quad & A_1 \rightarrow x\\
                 & B_1 \rightarrow x\\
                 & C_1 \rightarrow y\\
                 & C_2 \rightarrow C A a\\
                 & C_3 \rightarrow C B b\\
                 & S_1 \rightarrow C \$
\end{align*}}
\parbox{.8\textwidth}{sfd}
\end{tabular}

\parbox{.3\textwidth}{\begin{align*}
&traces(G_7) \equiv \\
\{ & \langle shift(y), reduce(C_1), switch(\$), reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), reduce(A_1), switch(a), reduce(C_2), switch(\$), reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), reduce(B_1), switch(b), reduce(C_3), switch(\$), reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), reduce(A_1), switch(a), reduce(C_2), switch(x), reduce(A_1), \\&\qquad switch(a), reduce(C_2), switch(\$), reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), reduce(B_1), switch(b), reduce(C_3), switch(x), reduce(A_1), \\&\qquad switch(a), reduce(C_2), switch(\$), reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), reduce(A_1), switch(a), reduce(C_2), switch(x), reduce(B_1), \\&\qquad switch(b), reduce(C_3), switch(\$), reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), reduce(B_1), switch(b), reduce(C_3), switch(x), reduce(B_1), \\&\qquad switch(b), reduce(C_3), switch(\$), reduce(S_1) \rangle,\\
   & \textellipsis \}
\end{align*}}

The equivalent trace with delays can be written as follows:

\parbox{.3\textwidth}{\begin{align*}
&traces(G_7) \equiv \\
\{ & \langle shift(y), reduce(C_1), switch(\$), reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), delay(A,B), switch(a), resolve(A_1), reduce(C_2), switch(\$), \\&\qquad reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), delay(A,B), switch(b), resolve(B_1), reduce(C_3), switch(\$), \\&\qquad reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), delay(A,B), switch(a), resolve(A_1), reduce(C_2), switch(x), \\&\qquad delay(A,B), switch(a), resolve(A_1), reduce(C_2), switch(\$), reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), delay(A,B), switch(a), resolve(A_1), reduce(C_2), switch(x), \\&\qquad delay(A,B), switch(b), resolve(B_1), reduce(C_3), switch(\$), reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), delay(A,B), switch(b), resolve(B_1), reduce(C_3), switch(x), \\&\qquad delay(A,B), switch(b), resolve(B_1), reduce(C_3), switch(\$), reduce(S_1) \rangle,\\
   & \langle shift(y), reduce(C_1), switch(x), delay(A,B), switch(b), resolve(B_1), reduce(C_3), switch(x), \\&\qquad delay(A,B), switch(a), resolve(A_1), reduce(C_2), switch(\$), reduce(S_1) \rangle,\\
   & \textellipsis \}
\end{align*}}

%%%%%%%%%%%%% Example 8: 
\subsubsection{}
\begin{tabular}[t]{cl}
\parbox{.3\textwidth}{
\begin{align*}
G_8 \equiv \quad & A_1 \rightarrow x\\
                 & B_1 \rightarrow x\\
                 & C_1 \rightarrow y\\
                 & C_2 \rightarrow A C a\\
                 & C_3 \rightarrow C B b\\
                 & S_1 \rightarrow C \$
\end{align*}}
\parbox{.8\textwidth}{sfd}
\end{tabular}

\parbox{.3\textwidth}{\begin{align*}
&traces(G_8) \equiv \\
\{ & \langle switch(y), reduce(C_1), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(A_1), switch(y), reduce(C_1), switch(a), reduce(C_2), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(y), reduce(C_1), switch(x), reduce(B_1), shift(b), reduce(C_3), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(A_1), switch(x), reduce(A_1), switch(y), reduce(C_1), shift(a), reduce(C_2), shift(a), \\&\qquad reduce(C_2), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(A_1), switch(y), reduce(C_1), switch(x), reduce(B_1), switch(b), reduce(C_3), shift(a), \\&\qquad reduce(C_2), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(A_1), switch(y), reduce(C_1), switch(a), reduce(C_2), switch(x), reduce(B_1), shift(b), \\&\qquad reduce(C_3), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(y), reduce(C_1), switch(x), reduce(B_1), shift(b), reduce(C_3), switch(x), reduce(B_1), shift(b), \\&\qquad reduce(C_3), switch(\$), reduce(S_1) \rangle,\\
   & \textellipsis \}
\end{align*}}

The equivalent trace with delays can be written as follows:

\parbox{.3\textwidth}{\begin{align*}
&traces(G_8) \equiv \\
\{ & \langle switch(y), reduce(C_1), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(A_1), switch(y), reduce(C_1), switch(a), reduce(C_2), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(y), reduce(C_1), switch(x), reduce(B_1), shift(b), reduce(C_3), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(A_1), switch(x), reduce(A_1), switch(y), reduce(C_1), shift(a), reduce(C_2), shift(a), \\&\qquad reduce(C_2), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(A_1), switch(y), reduce(C_1), switch(x), reduce(B_1), switch(b), reduce(C_3), shift(a), \\&\qquad reduce(C_2), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(x), reduce(A_1), switch(y), reduce(C_1), switch(a), reduce(C_2), switch(x), reduce(B_1), shift(b), \\&\qquad reduce(C_3), switch(\$), reduce(S_1) \rangle,\\
   & \langle switch(y), reduce(C_1), switch(x), reduce(B_1), shift(b), reduce(C_3), switch(x), reduce(B_1), shift(b), \\&\qquad reduce(C_3), switch(\$), reduce(S_1) \rangle,\\
   & \textellipsis \}
\end{align*}}

%S1{ C1{y} $ }
%S1{ C2{ A{x} C1{y} a} $ }
%S1{ C3{ C1{y} B{x} b } $ }
%S1{ C2{ A{x} C2{ A{x} C1{y} a } a } $ }
%S1{ C2{ A{x} C3{ C1{y} B{x} b } a } $ }
%S1{ C3{ C2{ A{x} C1{y} a } B{x} b } $ }
%S1{ C3{ C3{ C1{y} B{x} b } B{x} b } $ }

%(Surprisingly enough, this one needs no look-aheads)


%%%%%%%%%%%%% Example 9: A delayed rule in front of a cycle
\subsubsection{A delayed rule in front of a cycle}
\begin{tabular}[t]{cl}
\parbox{.3\textwidth}{
\begin{align*}
G_9 \equiv \quad & A_1 \rightarrow x\\
                 & B_1 \rightarrow x\\
                 & C_1 \rightarrow y\\
                 & C_2 \rightarrow C y\\
                 & S_1 \rightarrow A C a \$\\
                 & S_2 \rightarrow B C b \$
\end{align*}}
\parbox{.8\textwidth}{sfd}
\end{tabular}

\parbox{.3\textwidth}{\begin{align*}
&traces(G_9) \equiv \\
\{ & \langle shift(x), reduce(A_1), shift(y), reduce(C_1), switch(a), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), reduce(B_1), shift(y), reduce(C_1), switch(b), shift(\$), reduce(S_2) \rangle,\\
   & \langle shift(x), reduce(A_1), shift(y), reduce(C_1), switch(y), reduce(C_2), switch(a), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), reduce(B_1), shift(y), reduce(C_1), switch(y), reduce(C_2), switch(b), shift(\$), reduce(S_2) \rangle,\\
   & \textellipsis \}
\end{align*}}

The equivalent trace with delays can be written as follows:

\parbox{.3\textwidth}{\begin{align*}
&traces(G_9) \equiv \\
\{ & \langle shift(x), delay(A,B), shift(y), reduce(C_1), switch(a), resolve(A_1), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), delay(A,B), shift(y), reduce(C_1), switch(b), resolve(B_1), shift(\$), reduce(S_2) \rangle,\\
   & \langle shift(x), delay(A,B), shift(y), reduce(C_1), switch(y), reduce(C_2), switch(a), resolve(A), shift(\$), \\&\qquad reduce(S_1) \rangle,\\
   & \langle shift(x), delay(A,B), shift(y), reduce(C_1), switch(y), reduce(C_2), switch(b), resolve(B), shift(\$), \\&\qquad reduce(S_2) \rangle,\\
   & \textellipsis \}
\end{align*}}

%S1 { A{x} C1{y} a }
%S2 { B{x} C1{y} b }
%S1 { A{x} C2{ C1{y} y } a }
%S2 { B{x} C2{ C1{y} y } b }


%%%%%%%%%%%%% Example 10: Looking ahead into a cycle
\subsubsection{Looking ahead into a cycle}
\begin{tabular}[t]{cl}
\parbox{.3\textwidth}{
\begin{align*}
G_{10} \equiv \quad & A_1 \rightarrow x\\
                  & B_1 \rightarrow x\\
                  & C_1 \rightarrow a\\
                  & C_2 \rightarrow y C\\
                  & D_1 \rightarrow b\\
                  & D_2 \rightarrow y C\\
                  & S_1 \rightarrow A C \$\\
                  & S_2 \rightarrow B D \$
\end{align*}}
\parbox{.8\textwidth}{sfd}
\end{tabular}

\parbox{.3\textwidth}{\begin{align*}
&traces(G_{10}) \equiv \\
\{ & \langle shift(x), reduce(A_1), switch(a), reduce(C_1), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), reduce(B_1), switch(b), reduce(D_1), shift(\$), reduce(S_2) \rangle,\\
   & \langle shift(x), reduce(A_1), switch(y), switch(a), reduce(C_1), reduce(C_2), shift(\$), reduce(S_1) \rangle,\\
   & \langle shift(x), reduce(B_1), switch(y), switch(b), reduce(D_1), reduce(D_2), shift(\$), reduce(S_2) \rangle,\\
   & \textellipsis \}
\end{align*}}

The equivalent trace with delays can be written as follows:

\parbox{.3\textwidth}{\begin{align*}
&traces(G_{10}) \equiv \\
 \{ & \langle shift(x), delay(A, B), switch(a), reduce(C_1), resolve(A), shift(\$), reduce(S_1) \rangle,\\
    & \langle shift(x), delay(A, B), switch(b), reduce(D_1), resolve(B), shift(\$), reduce(S_2) \rangle,\\
    & \langle shift(x), delay(A, B), switch(y), switch(a), reduce(C_1), reduce(C_2), resolve(A), shift(\$), \\&\qquad reduce(S_1) \rangle,\\
    & \langle shift(x), delay(A, B), switch(y), switch(b), reduce(D_1), reduce(D_2), resolve(B), shift(\$), \\&\qquad reduce(S_2) \rangle,\\
    & \textellipsis \}
\end{align*}}

%S1 { A{x} C1{a} $ }
%S2 { B{x} D1{b} $ }
%S1 { A{x} C2{ y C1{a} } $ }
%S2 { B{x} D2{ y D1{b} } $ }

%%%%%%%%%%%%%%%%%%% IMPLEMENTATION
\section{Implementation}
\subsection{Parser construction}
\subsection{Parser interpreter}

\section*{Results}

\section*{Conclusions}

\section*{Future work}

\emph{ %BUSY HERE
(TODO)\\
Open problems: problematic unambiguous context-free grammars (nested lookahead problem + construction problem), progressive parsing (combining the recognition and builder passes), formal proofs of correctness\\
Performance analysis and benchmarks\\
Termination analysis\\
Parallelization?\\
Application to other grammar classes (E.g. ambiguous context-free and context-sensitive grammars)\\
Perhaps applications to other dynamic programming problems? How does it relate to automatic memoization in functional programming? (I.e. Memoization is an automatically deduced top-down dynamic programming mechanism. Is it possible to find bottom-up/hybrid solutions automatically?)
}

\bibliographystyle{plain}
\bibliography{delayedcase}

\end{document}

