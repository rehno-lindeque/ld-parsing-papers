\documentclass[envcountsame,runningheads]{llncs}
\usepackage{pscproc2}
%\usepackage{url}

%\usepackage{tikz}
%\usepackage{geometry}
%\geometry{a4paper}
%\usepackage{gcl}
%\usepackage{float}
%\usepackage{wrapfig}
\usepackage{proof}
%\usepackage{amssymb}
%\usepackage{amsthm}
\usepackage{amsmath}


% This is the shorter version of the technical report on "left-to-right parsing with delayed reductions" for the Prague Stringology Conference
\begin{document}
\title{Left-to-right parsing with delayed reductions}
\author{Rehno Lindeque \and Derrick Kourie}
\institute{University of Pretoria\\
\email{research@rehno.lindeque.name}}
\maketitle

\begin{abstract}
In this paper we suggest the use of delayed actions for parsing context-free languages.
We develop tools to study and develop the semantics of a domain specific language for building parsers with delayed reductions.
An informal proof shows that a parser implemented using our semantics will perform in linear time with respect to the number of lexical tokens.
Finally a prototype parser generator is described, capable of automatically generating parsers for a subset of context-free grammars.
\end{abstract}

\begin{keywords}
LD parser, recursive-ascent parser, context-free grammar, parser generator, bottom-up parser, top-down parser, delayed reductions
\end{keywords}

\section{Introduction}

[todo]

The remainder of this paper will be structured as follows. 
The operational semantics for a small, domain specific instruction set is developed.
[todo]

\section{Delayed reductions}

Our parsing strategy is divided into two passes.
[todo]

\subsection{Operational semantics}

\begin{equation}
\infer{i, j \mapsto i+1, j+1}{input_i = a & actions_j = shift(a)} \tag{shift}
\end{equation}

\begin{equation}
\infer{parserstate \mapsto error}{input_i = a & actions_j = shift(b)} \tag{shift-error}
\end{equation}

\begin{equation}
\infer{i, j, lasttarget, callstack_l, l \mapsto i+1, A_{input_i}, A_{input_i}, j+1, l+1}{input_i \in A & actions_j = switch(A)} \tag{switch}
\end{equation}

\begin{equation}
\infer{parsestate \mapsto error}{input_i \notin A & actions_j = switch(A)} \tag{switch-error}
\end{equation}

\begin{equation}
\infer{j, rulesbu\!f\!f\!er_k, k \mapsto j+1, r, k+1}{actions_j = reduce(r)} \tag{reduce}
\end{equation}

\begin{equation}
\infer{delays_m, m, j, rulesbu\!f\!f\!er_k, k \mapsto k, m+1, j+1, ignore, k+1}{actions_j = delay} \tag{delay}
\end{equation}

\begin{equation}
\infer{l, j, rulesbu\!f\!f\!er_{delays_{m-1}}, m \mapsto l-1, j+1, r, m-1}{actions_j = resolve(r)} \tag{resolve}
\end{equation}

\begin{equation}
\infer{j, l \mapsto callstack_{l-1}, l-1}{actions_j = return} \tag{return}
\end{equation}

\begin{equation}
\infer{j \mapsto A_{lasttarget}}{lasttarget \in A & actions_j = goto(A)} \tag{goto}
\end{equation}

\subsection{Trace semantics}

In order to translate a given string into a concrete syntax tree an LR parser must perform a sequence of $shi\!ft$ and $reduce$ operations.
For a given grammar $G$ we can mechanically generate a \emph{trace} of this sequence of operations on any string in the language $\boldsymbol{L}(G)$.
Restricting the traces to $shi\!ft$ and $reduce$ operations in an LR parser allows us to study the desired semantics of the parser independent of its lookahead mechanism, an orthogonal concern.
As most grammars of interest generate languages containing infinite sets of strings, the corresponding parsers will also generate an infinite set of traces, $traces(G)$.
Clearly the set of traces that a concrete $LR(k)$ parser with fixed lookahead $k$ can generate is restricted in the same way that the set of strings it can translate is restricted.
If we can construct an $LR(k)$ parser of finite length where $k$ is specified\footnote{The constraint that $k$ must be specified is important because finding such a $k$ automatically is undecidable in general.},
then $G$ fall in the class of $LR(k)$ grammars.
It is not \emph{generally} possible to determine whether all the strings generated by a grammar can be parsed by a LD parser\footnote{In other words no algorithm exists to test whether a grammmar falls in a class of $LD$ grammars.}.
None-the-less, we wish to show that it is indeed possible to construct LD parsers of finite length for a broad class of grammars that include all $LR(k)$ grammars for any fixed value of $k$.

%If we can show that the set of traces a concrete LD parser will generate is equivalent to the set of traces generated by a theoretical LR parser then those parsers have the same strength.

\section{A prototype parser generator}

As it is not possible to determine whether a grammar will fall in a class of $LD$ grammars,
there is no way of implementing a parser generator that will report any invalid grammar.
However, we do have an intuitive notion of what a practical parser should look like.
Instead of arbitrarily restricting the lookahead that a parser can handle\footnote{...as is the case with $LR(k)$ parsers.},
we simply restrict the complexity of the generated parser.
Practically this simply means that some termination condition must be supplied to the parser generator such as an upper bound on the size of the parser.

\section{Results}

By mechanically generating traces for the following grammars we are able to show which can be parsed successfully. [todo]

\section{Conclusions}
An earlier technical report describing additional details of the parsing DSL and parser generator can be found in \cite{Lin11}.

\section{Future work}

It remains to develop a generalized LD parser for all context-free grammars, including those with ambiguities. 
Such GLD parsers would be equivalent in strength to GLR parsers, however it is hoped that such
a development would demonstrate superior performance to previous methods.

\bibliographystyle{psc}
\bibliography{ldparsing}

\end{document}

